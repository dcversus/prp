/**
 * Version utility to get version dynamically from package.json
 */
import { readFileSync, existsSync } from 'fs';
import { dirname, join, basename } from 'path';
import { fileURLToPath } from 'url';

import { logger } from '../logger.js';

const currentFilename = fileURLToPath(import.meta.url);
const currentDirname = dirname(currentFilename);
// Cache the version to avoid reading package.json repeatedly
let cachedVersion: string | null = null;
/**
 * Get the current version from package.json
 * @returns The version string from package.json
 */
export function getVersion(): string {
  if (cachedVersion) {
    return cachedVersion;
  }
  try {
    // Read package.json from the project root
    const packageJsonPath = join(currentDirname, '../../package.json');
    const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf8'));
    const version = packageJson.version ?? '0.0.0';
    cachedVersion = version;
    return version;
  } catch (error) {
    logger.debug(
      'shared',
      'version',
      'Could not read version from package.json, using fallback:',
      error instanceof Error ? error.message : String(error),
    );
    return '0.0.0';
  }
}
/**
 * Get the full package name with version
 * @returns The package name with version (e.g., "@dcversus/prp@0.4.9")
 */
export function getPackageVersion(): string {
  try {
    const packageJsonPath = join(currentDirname, '../../package.json');
    const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf8'));
    const name = packageJson.name ?? '@dcversus/prp';
    const version = getVersion();
    return `${name}@${version}`;
  } catch (error) {
    logger.debug(
      'shared',
      'version',
      'Could not read package name from package.json, using fallback:',
      error instanceof Error ? error.message : String(error),
    );
    return '@dcversus/prp@0.0.0';
  }
}
/**
 * Get the user agent string for HTTP requests
 * @returns A user agent string with the current version
 */
export function getUserAgent(service = 'prp-cli'): string {
  const version = getVersion();
  return `${service}/${version}`;
}
/**
 * Get the CLI user agent string
 * @returns The CLI user agent string
 */
export function getCliUserAgent(): string {
  return getUserAgent('prp-cli');
}
/**
 * Get the orchestrator user agent string
 * @returns The orchestrator user agent string
 */
export function getOrchestratorUserAgent(): string {
  return getUserAgent('@dcversus/prp-orchestrator');
}
/**
 * Generate a banner string with version info
 * @param template The template string to use
 * @returns The formatted banner with version
 */
export function getVersionBanner(template = 'Generated by PRP CLI v{version}'): string {
  const version = getVersion();
  return template.replace('{version}', version);
}
/**
 * Get a dependency version for templates
 * @returns The current version with ^ prefix for package.json dependencies
 */
export function getDependencyVersion(): string {
  const version = getVersion();
  return `^${version}`;
}

// Cache for project name detection
let cachedProjectName: string | null = null;

/**
 * Detect the current project name from package.json or folder name
 * @param cwd The current working directory (defaults to process.cwd())
 * @returns The detected project name with proper branding format
 */
export function detectProjectName(cwd?: string): string {
  if (cachedProjectName && !cwd) {
    return cachedProjectName;
  }

  try {
    const workingDir = cwd || process.cwd();
    const packageJsonPath = join(workingDir, 'package.json');

    // Try to read from package.json first
    if (existsSync(packageJsonPath)) {
      try {
        const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf8'));
        const projectName = packageJson.name;

        if (projectName && typeof projectName === 'string') {
          // Format as ♫ @org/project if it's a scoped package, or ♫ project-name
          const formattedName = projectName.startsWith('@')
            ? `♫ ${projectName}`
            : `♫ ${projectName}`;

          // Cache only if using default cwd
          if (!cwd) {
            cachedProjectName = formattedName;
          }

          logger.debug(
            'shared',
            'version',
            `Detected project name from package.json: ${formattedName}`,
          );
          return formattedName;
        }
      } catch (parseError) {
        logger.debug(
          'shared',
          'version',
          'Failed to parse package.json, falling back to folder name:',
          parseError instanceof Error ? parseError.message : String(parseError),
        );
      }
    }

    // Fall back to folder name
    const folderName = basename(workingDir);
    const formattedFolderName = `♫ ${folderName}`;

    // Cache only if using default cwd
    if (!cwd) {
      cachedProjectName = formattedFolderName;
    }

    logger.debug('shared', 'version', `Using folder name as project name: ${formattedFolderName}`);
    return formattedFolderName;
  } catch (error) {
    logger.debug(
      'shared',
      'version',
      'Could not detect project name, using default:',
      error instanceof Error ? error.message : String(error),
    );

    const defaultName = '♫ @dcversus/prp';
    if (!cwd) {
      cachedProjectName = defaultName;
    }
    return defaultName;
  }
}

/**
 * Reset the cached project name (useful for testing or directory changes)
 */
export function resetProjectNameCache(): void {
  cachedProjectName = null;
}
