/**
 * â™« Enhanced Scanner Core Unit Tests
 */

import { EnhancedScannerCore } from '../enhanced-scanner-core';
import { EventBus } from '../../shared/events';
import { TimeUtils } from '../../shared';

// Mock dependencies
jest.mock('../../shared/events');
jest.mock('../../shared/logger');
jest.mock('../../shared/utils');

describe('EnhancedScannerCore', () => {
  let scanner: EnhancedScannerCore;
  let eventBus: jest.Mocked<EventBus>;
  let mockConfig: any;

  // Helper function to mock scanner methods without signature issues
  function mockScannerMethods(scannerInstance: EnhancedScannerCore) {
    const mockDiscoverWorktrees = jest.fn().mockResolvedValue(undefined);
    const mockStartFileSystemMonitoring = jest.fn().mockReturnValue(undefined);
    const mockStartPeriodicScanning = jest.fn().mockReturnValue(undefined);
    const mockPerformComprehensiveScan = jest.fn().mockResolvedValue(undefined);
    const mockDetectSignalsInPRP = jest.fn().mockResolvedValue([]);
    const mockEmitScannerEvent = jest.fn().mockReturnValue(undefined);
    const mapPriorityToLevel = jest.fn().mockReturnValue('info');

    // Replace methods with mocks
    (scannerInstance as any).discoverWorktrees = mockDiscoverWorktrees;
    (scannerInstance as any).startFileSystemMonitoring = mockStartFileSystemMonitoring;
    (scannerInstance as any).startPeriodicScanning = mockStartPeriodicScanning;
    (scannerInstance as any).performComprehensiveScan = mockPerformComprehensiveScan;
    (scannerInstance as any).detectSignalsInPRP = mockDetectSignalsInPRP;
    (scannerInstance as any).emitScannerEvent = mockEmitScannerEvent;
    (scannerInstance as any).mapPriorityToLevel = mapPriorityToLevel;

    return {
      mockDiscoverWorktrees,
      mockStartFileSystemMonitoring,
      mockStartPeriodicScanning,
      mockPerformComprehensiveScan,
      mockDetectSignalsInPRP,
      mockEmitScannerEvent,
      mapPriorityToLevel
    };
  }

  beforeEach(() => {
    // Reset mocks
    jest.clearAllMocks();

    // Create mock event bus
    eventBus = {
      publishToChannel: jest.fn(),
      on: jest.fn(),
      off: jest.fn(),
      emit: jest.fn()
    } as any;

    // Mock configuration
    mockConfig = {
      scanInterval: 1000,
      maxConcurrentScans: 5,
      batchSize: 10,
      enableGitMonitoring: true,
      enableFileMonitoring: true,
      enablePRPMonitoring: true,
      excludedPaths: ['**/node_modules/**'],
      includedExtensions: ['.ts', '.js', '.md'],
      worktreePaths: [],
      performanceThresholds: {
        maxScanTime: 5000,
        maxMemoryUsage: 100000000,
        maxFileCount: 10000
      }
    };

    // Create scanner instance
    scanner = EnhancedScannerCore.getInstance(mockConfig, eventBus);
  });

  afterEach(async () => {
    if (scanner) {
      await scanner.stop();
    }
  });

  describe('Singleton Pattern', () => {
    it('should return the same instance for multiple calls', () => {
      const scanner1 = EnhancedScannerCore.getInstance(mockConfig, eventBus);
      const scanner2 = EnhancedScannerCore.getInstance(mockConfig, eventBus);

      expect(scanner1).toBe(scanner2);
    });

    it('should throw error when config is not provided on first call', () => {
      expect(() => {
        EnhancedScannerCore.getInstance(undefined as any, eventBus);
      }).toThrow('Config and EventBus required for first initialization');
    });
  });

  describe('Initialization', () => {
    it('should initialize successfully', async () => {
      // Mock successful discovery using helper
      mockScannerMethods(scanner);

      await expect(scanner.initialize()).resolves.not.toThrow();

      expect(scanner['isInitialized']).toBe(true);
    });

    it('should emit initialization event', async () => {
      const emitSpy = jest.spyOn(scanner, 'emit');

      // Mock successful discovery using helper
      mockScannerMethods(scanner);

      await scanner.initialize();

      expect(emitSpy).toHaveBeenCalledWith('scanner:event', expect.objectContaining({
        type: 'system_event',
        data: expect.objectContaining({
          type: 'scanner_initialized'
        })
      }));
    });
  });

  describe('Scanning Operations', () => {
    beforeEach(async () => {
      // Mocked via helper
      // Mocked via helper
      jest.spyOn(scanner as any, 'startPeriodicScanning').mockReturnValue();
      jest.spyOn(scanner as any, 'performComprehensiveScan').mockResolvedValue();

      await scanner.initialize();
    });

    it('should start scanning operations', async () => {
      const performScanSpy = jest.spyOn(scanner as any, 'performComprehensiveScan').mockResolvedValue();

      await scanner.start();

      expect(scanner['isScanning']).toBe(true);
      expect(performScanSpy).toHaveBeenCalled();
    });

    it('should emit scanner started event', async () => {
      const emitSpy = jest.spyOn(scanner, 'emit');

      await scanner.start();

      expect(emitSpy).toHaveBeenCalledWith('scanner:event', expect.objectContaining({
        type: 'system_event',
        data: expect.objectContaining({
          type: 'scanner_started'
        })
      }));
    });

    it('should stop scanning operations', async () => {
      await scanner.start();
      await scanner.stop();

      expect(scanner['isScanning']).toBe(false);
    });

    it('should handle file changes with debouncing', async () => {
      const handleFileChangeSpy = jest.spyOn(scanner as any, 'handleFileChange');
      const filePath = '/test/file.ts';

      // Simulate rapid file changes
      scanner['debounceFileChange'](filePath, 'modified');
      scanner['debounceFileChange'](filePath, 'modified');
      scanner['debounceFileChange'](filePath, 'modified');

      // Wait for debounce
      await new Promise(resolve => setTimeout(resolve, 600));

      expect(handleFileChangeSpy).toHaveBeenCalledTimes(1);
      expect(handleFileChangeSpy).toHaveBeenCalledWith(filePath, 'modified');
    });

    it('should detect PRP files and trigger signal detection', async () => {
      const detectSignalsSpy = jest.spyOn(scanner as any, 'detectSignalsInPRP').mockResolvedValue();
      const prpPath = '/test/PRPs/test-prp.md';

      await scanner['handleFileChange'](prpPath, 'modified');

      expect(detectSignalsSpy).toHaveBeenCalledWith(
        expect.objectContaining({ path: prpPath }),
        prpPath
      );
    });
  });

  describe('State Management', () => {
    beforeEach(async () => {
      // Mocked via helper
      // Mocked via helper
      jest.spyOn(scanner as any, 'startPeriodicScanning').mockReturnValue();
      jest.spyOn(scanner as any, 'performComprehensiveScan').mockResolvedValue();

      await scanner.initialize();
    });

    it('should return current scanner state', () => {
      const state = scanner.getState();

      expect(state).toHaveProperty('status');
      expect(state).toHaveProperty('config');
      expect(state).toHaveProperty('monitors');
      expect(state).toHaveProperty('metrics');
      expect(state).toHaveProperty('alerts');
    });

    it('should return worktree status', () => {
      const status = scanner.getWorktreeStatus('test-worktree');

      // Should return null for non-existent worktree
      expect(status).toBeNull();
    });

    it('should return all worktree statuses', () => {
      const statuses = scanner.getAllWorktreeStatuses();

      expect(Array.isArray(statuses)).toBe(true);
    });

    it('should return token usage statistics', () => {
      const tokenUsage = scanner.getTokenUsage();

      expect(tokenUsage).toBeInstanceOf(Map);
      expect(tokenUsage.has('system')).toBe(true);
    });

    it('should update performance metrics', () => {
      const initialMetrics = scanner.getMetrics();

      scanner['updateScanMetrics'](1000);

      const updatedMetrics = scanner.getMetrics();

      expect(updatedMetrics.totalScans).toBe(initialMetrics.totalScans + 1);
      expect(updatedMetrics.averageScanTime).toBeGreaterThan(0);
    });
  });

  describe('Token Accounting', () => {
    beforeEach(async () => {
      // Mocked via helper
      // Mocked via helper
      jest.spyOn(scanner as any, 'startPeriodicScanning').mockReturnValue();
      jest.spyOn(scanner as any, 'performComprehensiveScan').mockResolvedValue();

      await scanner.initialize();
    });

    it('should record token usage', () => {
      const recordUsageSpy = jest.spyOn(scanner['tokenAccounting'], 'recordUsage');

      scanner.recordTokenUsage(
        'test-agent',
        'robo-developer',
        'test-operation',
        'gpt-4',
        1000,
        500,
        { test: 'metadata' }
      );

      expect(recordUsageSpy).toHaveBeenCalledWith(
        'test-agent',
        'robo-developer',
        'test-operation',
        'gpt-4',
        1000,
        500,
        'scanner',
        { test: 'metadata' }
      );
    });

    it('should emit token usage events', () => {
      const emitSpy = jest.spyOn(scanner, 'emit');

      scanner.recordTokenUsage(
        'test-agent',
        'robo-developer',
        'test-operation',
        'gpt-4',
        1000,
        500
      );

      expect(emitSpy).toHaveBeenCalledWith('scanner:event', expect.objectContaining({
        type: 'system_event',
        data: expect.objectContaining({
          type: 'token_usage'
        })
      }));
    });
  });

  describe('Error Handling', () => {
    it('should handle initialization errors gracefully', async () => {
      const mockScanner = EnhancedScannerCore.getInstance(mockConfig, eventBus);

      // Mock an error during initialization
      jest.spyOn(mockScanner as any, 'discoverWorktrees').mockRejectedValue(new Error('Test error'));

      await expect(mockScanner.initialize()).rejects.toThrow('Test error');
      expect(mockScanner['state'].status).toBe('error');
    });

    it('should handle file change errors gracefully', async () => {
      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();

      // Mocked via helper
      // Mocked via helper
      jest.spyOn(scanner as any, 'startPeriodicScanning').mockReturnValue();
      jest.spyOn(scanner as any, 'performComprehensiveScan').mockResolvedValue();

      await scanner.initialize();

      // Mock an error during file change handling
      jest.spyOn(scanner as any, 'findWorktreeForFile').mockImplementation(() => {
        throw new Error('File error');
      });

      // Should not throw error
      await expect(scanner['handleFileChange']('/test/file.ts', 'modified')).resolves.not.toThrow();

      expect(consoleSpy).toHaveBeenCalled();

      consoleSpy.mockRestore();
    });

    it('should update error count on scan failures', async () => {
      // Mocked via helper
      // Mocked via helper
      jest.spyOn(scanner as any, 'startPeriodicScanning').mockReturnValue();

      // Mock scan error
      jest.spyOn(scanner as any, 'performComprehensiveScan').mockRejectedValue(new Error('Scan error'));

      await scanner.initialize();

      const initialErrorCount = scanner['state'].metrics.performance.errorRate;

      await scanner.start();

      // Error count should be tracked
      expect(scanner['state'].metrics.performance.errorRate).toBeGreaterThan(initialErrorCount);
    });
  });

  describe('Performance Monitoring', () => {
    beforeEach(async () => {
      // Mocked via helper
      // Mocked via helper
      jest.spyOn(scanner as any, 'startPeriodicScanning').mockReturnValue();
      jest.spyOn(scanner as any, 'performComprehensiveScan').mockResolvedValue();

      await scanner.initialize();
    });

    it('should track scan metrics', () => {
      const initialMetrics = scanner.getMetrics();

      // Simulate multiple scans
      scanner['updateScanMetrics'](100);
      scanner['updateScanMetrics'](200);
      scanner['updateScanMetrics'](150);

      const updatedMetrics = scanner.getMetrics();

      expect(updatedMetrics.totalScans).toBe(initialMetrics.totalScans + 3);
      expect(updatedMetrics.averageScanTime).toBeGreaterThan(0);
      expect(updatedMetrics.performance.fastestScan).toBe(100);
      expect(updatedMetrics.performance.slowestScan).toBe(200);
    });

    it('should emit scanner events', () => {
      const emitSpy = jest.spyOn(scanner, 'emit');

      scanner['emitScannerEvent']({
        type: 'test_event',
        timestamp: new Date(),
        source: 'test',
        data: { test: true },
        priority: 'medium'
      });

      expect(emitSpy).toHaveBeenCalledWith('scanner:event', expect.objectContaining({
        type: 'test_event',
        source: 'test',
        data: { test: true },
        priority: 'medium'
      }));
    });
  });

  describe('Utility Methods', () => {
    beforeEach(async () => {
      // Mocked via helper
      // Mocked via helper
      jest.spyOn(scanner as any, 'startPeriodicScanning').mockReturnValue();
      jest.spyOn(scanner as any, 'performComprehensiveScan').mockResolvedValue();

      await scanner.initialize();
    });

    it('should detect PRP files correctly', () => {
      expect(scanner['isPRPFile']('PRPs/test-prp.md')).toBe(true);
      expect(scanner['isPRPFile']('src/test.ts')).toBe(false);
      expect(scanner['isPRPFile']('docs/readme.md')).toBe(false);
    });

    it('should estimate file tokens correctly', () => {
      const jsTokens = scanner['estimateFileTokens']('test.js');
      const tsTokens = scanner['estimateFileTokens']('test.ts');
      const mdTokens = scanner['estimateFileTokens']('test.md');
      const unknownTokens = scanner['estimateFileTokens']('test.unknown');

      expect(tsTokens).toBeGreaterThan(jsTokens); // TypeScript has higher multiplier
      expect(mdTokens).toBeGreaterThan(jsTokens); // Markdown has higher multiplier
      expect(unknownTokens).toBe(1000); // Default value
    });

    it('should map priority to level correctly', () => {
      expect(scanner['mapPriorityToLevel'](9)).toBe('critical');
      expect(scanner['mapPriorityToLevel'](7)).toBe('high');
      expect(scanner['mapPriorityToLevel'](5)).toBe('medium');
      expect(scanner['mapPriorityToLevel'](2)).toBe('low');
    });

    it('should extract worktree name from path', () => {
      expect(scanner['extractWorktreeName']('/path/to/worktree')).toBe('worktree');
      expect(scanner['extractWorktreeName']('worktree')).toBe('worktree');
    });
  });
});